function loop_str = fun_analysis_get_loops_in_graph_by_link_label(graph_str, link_label, distance_type)
% fun_analysis_get_loops_in_graph finds loops for the specified link in the
% graph and compute loop length
% Input: 
%   graph_str: structure generated by fun_analysis_get_connectivity_graph
%   link_label: numerical vector, label of links for finding the loops
%   distance_type: string, one of {'geodesic', 'euclidean'}
% Output:
%   loop_str: structure with fields:
%       link_label: numerical vector, label of link
%       loop_node_label: cell array, labels of the nodes in the loop
%       loop_link_label:  cell array, labels of the links in the loop
%       num_loop: numerical scalar, number of loop found 
%       loop_length: numerical vector, sum of the euclidean length of the loop
%       loop_geodesic_length: numerical vector, number of edges in the loop
%
% Note: 
% 1. This function only work for undirected graph
% 2. This function assume the graph does not have self-loop
% 3. This function works for multiedge graph. 
% Implemented by Xiang Ji on 02/25/2019
% Modified by Xiang Ji on 05/04/2019
% 1. Remove the edge by setting its weight to inf - reduce 50% of the
% computational time
% 2. Fix a bug: now in the output loop_str, all the arraies have the same
% size as link_label and the order is preserved. 
if nargin < 2
    distance_type = 'geodesic';
end
num_edge = numel(link_label);

loop_str = fun_initialized_structure_array_with_fieldname_list({'link_label', ...
    'loop_node_label', 'loop_link_label', 'num_loop', 'loop_length', 'loop_geodesic_length'});
if num_edge == 0
    return;
end
% Find idx for the link label - can be replace by intersect later.
[~, found_idx, test_link_idx] = intersect(link_label, graph_str.used_link_label, 'stable');
% [test_link_idx, found_idx] = find((graph_str.used_link_label -  link_label) == 0);
link_exist_in_graph_Q = false(num_edge, 1);
link_exist_in_graph_Q(found_idx) = true;
if ~all(link_exist_in_graph_Q)
%     warning('Exist input link label not used for constructing the graph');
end
test_node_pair = graph_str.used_node_label_pair(test_link_idx, :);

num_valid_edge = size(test_node_pair, 1);
loop_node_label_cell = cell(num_valid_edge, 1);
loop_link_label_cell = cell(num_valid_edge, 1);
path_geodesic_length = nan(num_valid_edge, 1);
path_length = nan(num_valid_edge, 1);

switch distance_type
    case 'geodesic'
        used_graph = graph_str.graph_uw;
    case 'euclidean'
        used_graph = graph_str.graph_w;
end
bilink_loop_str = graph_str.bilink_loop;
bilink_loop_type1_link_label = bilink_loop_str.link_label_pair(:);
bilink_loop_type2_link_label = cat(1, bilink_loop_str.link_label_pair_ge_3{:});
num_bilink_loop_type2 = numel(bilink_loop_str.link_label_pair_ge_3);
% Sort the node pair since this is an undirected graph 
edge_node_pairs = sort(used_graph.Edges.EndNodes, 2, 'ascend');
test_node_pair = sort(test_node_pair, 2, 'ascend');

for iter_edge = 1 : num_valid_edge
    tmp_node_pair = test_node_pair(iter_edge, :);
    tmp_link_label = full(graph_str.A_link_label(tmp_node_pair(1), tmp_node_pair(2)));
    
    tmp_is_bilink_loop_type_1 = any(bilink_loop_type1_link_label == tmp_link_label);
    tmp_is_bilink_loop_type_2 = any(bilink_loop_type2_link_label == tmp_link_label);  
    if ~tmp_is_bilink_loop_type_1 && ~tmp_is_bilink_loop_type_2
        tmp_edge_list_ind = find(edge_node_pairs(:, 1) == tmp_node_pair(1) & ...
            edge_node_pairs(:, 2) == tmp_node_pair(2));
        assert(isscalar(tmp_edge_list_ind), 'Should be a scalar');
        % Find the shortest path 
        test_graph = used_graph;
        test_graph.Edges.Weight(tmp_edge_list_ind) = inf;
        
        [tmp_path, tmp_path_length] = shortestpath(test_graph, ...
            test_node_pair(iter_edge, 1), test_node_pair(iter_edge, 2));
        
        if ~isempty(tmp_path) && isfinite(tmp_path_length)
            path_length(iter_edge) = tmp_path_length;
            % The path consist of the starting node and the ending node,
            % but since we are looking at the loop, the geodesic length of
            % the loop does not need to be subtracted by 1. 
            path_geodesic_length(iter_edge) = numel(tmp_path); 
            switch distance_type
                case 'euclidean'
%                     assert(tmp_edge_length == graph_str.used_link_length(test_link_idx(iter_edge)), 'The length retrived by two methods should be the same');
                    path_length(iter_edge) = path_length(iter_edge) + graph_str.used_link_length(test_link_idx(iter_edge));
            end
            tmp_ind = sub2ind(graph_str.Adj_mat_size, tmp_path, circshift(tmp_path, 1));
            
            loop_link_label_cell{iter_edge} = full(graph_str.A_link_label(tmp_ind));
            loop_node_label_cell{iter_edge} = tmp_path;
        else
            path_geodesic_length(iter_edge) = inf;
        end        
    elseif tmp_is_bilink_loop_type_1
        path_geodesic_length(iter_edge) = 2;
        
        [tmp_sub1, ~] = find(bilink_loop_str.link_label_pair == tmp_link_label);
        loop_node_label_cell{iter_edge} = bilink_loop_str.connected_node_label(tmp_sub1, :);
        
        path_length(iter_edge) = sum(bilink_loop_str.link_length_pair(tmp_sub1,:));
        loop_link_label_cell{iter_edge} = bilink_loop_str.link_label_pair(tmp_sub1,:);
    elseif tmp_is_bilink_loop_type_2
        path_geodesic_length(iter_edge) = 2;
        for iter = 1 : num_bilink_loop_type2
            tmp_label = bilink_loop_str.link_label_pair_ge_3{iter};
            tmp_Q = (tmp_link_label == tmp_label); 
            if any(tmp_Q)
                loop_node_label_cell{iter_edge} = bilink_loop_str.connected_node_label_ge_3(iter,:);
                tmp_link_length_list = bilink_loop_str.link_length_pair_ge_3{iter};
                tmp_link_length_1 = tmp_link_length_list(tmp_Q);
                tmp_idx = find(~tmp_Q);
                [tmp_link_length_2, tmp_min_idx]= min(tmp_link_length_list(~tmp_Q));
                path_length(iter_edge) = tmp_link_length_1 + tmp_link_length_2;
                loop_link_label_cell{iter_edge} = [tmp_link_label, tmp_label(tmp_idx(tmp_min_idx))];
                break;
            end
        end
    end
end
switch distance_type
    case 'geodesic'
        path_length = path_geodesic_length;
end

%% Construct output structure;
loop_str.link_label = link_label;
loop_str.loop_node_label = cell(num_edge, 1);
loop_str.loop_node_label(found_idx) = loop_node_label_cell;

loop_str.loop_link_label = cell(num_edge, 1);
loop_str.loop_link_label(found_idx) = loop_link_label_cell;

is_path_Q = isfinite(path_length);
loop_str.num_loop = nnz(is_path_Q);

loop_str.loop_length = nan(num_edge, 1);
loop_str.loop_length(found_idx) = path_length;

loop_str.loop_geodesic_length = nan(num_edge, 1);
loop_str.loop_geodesic_length(found_idx) = path_geodesic_length;
end