function [vessel_graph, varargout] = fun_graph_mask_to_graph(vessel_mask, vessel_image, opt)
% fun_graph_mask_to_graph is a wrap up function for converting the vessel
% mask to vessel graph. 
% Input: 
%   vessel_image: 3D numerical array of vessel image stack 
%   vessel_mask: 3D logical array of the vessel mask, generated by the
%   segmentation of the vessel image 
%   opt: structure with fields
% Output: 
%   vessel_graph: strucutre generated by fun_skeleton_to_graph
%   vessel_mask_dt: 3D single array, distance from the vessel lumen to the
%   vessel wall. 
% 
% Implemented by Xiang Ji on May 13, 2019
if nargin < 3
    opt = struct;
    opt.max_rc_int = 40000;
    opt.node_bbox_expand = 20;
end
assert(isnumeric(vessel_image), 'Vessel image should be a numerical array');
assert(islogical(vessel_mask), 'Vessel mask should be a logical array');
% disp('Skeletonization'); % ~60 sec for 1 tile
vessel_skl = bwskel(vessel_mask);
% disp('Skeleton to graph'); % 6 sec
vessel_graph = fun_skeleton_to_graph(vessel_skl);
% disp('Check the existance of holes in the mask');
large_node_label = find(vessel_graph.node.num_voxel_per_cc >= 5);
if ~isempty(large_node_label)
    large_node_cc_ind = vessel_graph.node.cc_ind(large_node_label);
    num_large_node_cc = numel(large_node_cc_ind);
    tmp_add_ind = cell(num_large_node_cc, 1);    
    for iter_node = 1 : num_large_node_cc
        tmp_ind = large_node_cc_ind{iter_node};
        tmp_sub = fun_ind2sub(vessel_graph.num.mask_size, tmp_ind);
        tmp_bbox_min = min(tmp_sub);
        tmp_bbox_max = max(tmp_sub);
        tmp_bbox_expand = [max([1,1,1], tmp_bbox_min - opt.node_bbox_expand), ...
            min(vessel_graph.num.mask_size, tmp_bbox_max + opt.node_bbox_expand)];
        tmp_bbox_size = tmp_bbox_expand(4:6) - tmp_bbox_expand(1:3) + 1;
        tmp_bbox = vessel_mask(tmp_bbox_expand(1) : tmp_bbox_expand(4), ...
            tmp_bbox_expand(2) : tmp_bbox_expand(5), tmp_bbox_expand(3) : tmp_bbox_expand(6));
        tmp_bbox_fill_hole = imfill(tmp_bbox, 'holes');
        tmp_diff_local_ind = find(tmp_bbox_fill_hole & ~tmp_bbox);
        if ~isempty(tmp_diff_local_ind)
            tmp_diff_local_sub = fun_ind2sub(tmp_bbox_size, tmp_diff_local_ind);
            tmp_diff_global_sub = tmp_diff_local_sub + tmp_bbox_expand(1:3) - 1;
            tmp_diff_global_ind = sub2ind(vessel_graph.num.mask_size, tmp_diff_global_sub(:, 1), ...
                tmp_diff_global_sub(:,2), tmp_diff_global_sub(:,3));
            tmp_add_ind{iter_node} = tmp_diff_global_ind;
        end
    end
    tmp_add_ind = cat(1, tmp_add_ind{:});
    if ~isempty(tmp_add_ind)
        vessel_mask(tmp_add_ind) = true;
        vessel_skl = bwskel(vessel_mask);
    end
end
% disp('Distance transform'); % 85 sec for 1 tile
vessel_mask_dt = bwdist(~vessel_mask);
% disp('Recentering');
rc_metric = min(opt.max_rc_int, vessel_image);
rc_metric = rc_metric + cast(ceil(vessel_mask_dt), class(rc_metric));
vessel_skl_rc = fun_skeleton_recentering_within_mask(vessel_skl, rc_metric, vessel_mask);
% Skeleton to graph
vessel_graph = fun_skeleton_to_graph(vessel_skl_rc);
if nargout > 1
    varargout{1} = vessel_mask_dt;
end    
end
%% Debug
% Get the voxel deleted that give raise to the creation of erroneous
% endpoint
% debug_ind = [307756433 877701048];
% debug_ep_label = full(vessel_graph_rc.endpoint.map_ind_2_label(debug_ind));
% debug_ep_label = debug_ep_label(debug_ep_label > 0);
% debug_link_label = vessel_graph_rc.endpoint.link_label(debug_ep_label);
% debug_ep_ind = vessel_graph_rc.endpoint.pos_ind(debug_ep_label);
% debug_ep_neighbor_ind = fun_graph_get_node_neighbor_voxel_ind(debug_ep_ind, ...
%     vessel_graph_rc.num.mask_size, 26);
% vessel_skl(debug_ep_neighbor_ind)
% debug_deleted_neighbor_ind = debug_ep_neighbor_ind(~vessel_skl_rc(debug_ep_neighbor_ind) & ...
%     vessel_skl(debug_ep_neighbor_ind));
% % If add one voxel, will the endpoint be removed? 
% debug_ep_neighbor_neighbor_ind = debug_ep_neighbor_ind;
% debug_ep_neighbor_neighbor_ind = fun_graph_get_node_neighbor_voxel_ind(debug_ep_neighbor_neighbor_ind, ...
%     vessel_graph_rc.num.mask_size, 26);
% vessel_graph_rc.link.map_ind_2_label(debug_ep_neighbor_neighbor_ind)
% 
% fun_vis_link_surrounding_by_cc_ind(vessel_image, vessel_mask, vessel_skl, vessel_graph_rc.link.cc_ind{15471});