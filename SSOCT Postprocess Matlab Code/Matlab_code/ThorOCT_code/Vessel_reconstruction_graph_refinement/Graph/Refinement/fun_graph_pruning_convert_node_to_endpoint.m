function [input_graph, new_link_info] = fun_graph_pruning_convert_node_to_endpoint(input_graph, node_label)
% fun_graph_pruning_convert_node_to_endpoint convert a node of degree 1 to
% an endpoint. If the node contains more than 1 voxel, select one of these
% voxels that connected to the link. 
% Input: 
%   input_graph: structure generated by fun_skeleton_to_graph
%   node_label: label of node to be converted
% Output: 
%   input_graph: updated structure
%   new_link_info: strucutre with fields: 
%       ep_ind: linear index of the endpoint ( one of the voxels in the
%       original node connected component) 
%       link_cc_ind: the linear indices of the new link connected component
% Written by Xiang Ji on Jan 27, 2019
%
%
% This temporare field record the link label after graph modification. The
% map_ind_to_label is not updated during the modification due to
% performance consideration.
if ~isfield(input_graph, 'tmp_link_ind_old_to_new')
    input_graph.tmp_link_ind_old_to_new = 0 : input_graph.link.num_cc;
end

link_label = input_graph.node.connected_link_label{node_label};
assert(isscalar(link_label), 'More than 1 links connected to the node to be converted to endpoint');

link_cc_ind = input_graph.link.cc_ind{link_label};
node_ind = input_graph.node.cc_ind{node_label};

% Find the node voxels that connect to the link
tmp_sub = fun_ind2sub(input_graph.num.mask_size, node_ind);
node_ind_pad = sub2ind(input_graph.num.mask_size_pad, tmp_sub(:,1)+1, ...
    tmp_sub(:,2)+1, tmp_sub(:,3)+1);
node_n26_ind_pad = bsxfun(@plus, node_ind_pad', input_graph.num.neighbor_add_pad);
tmp_sub_pad = fun_ind2sub(input_graph.num.mask_size_pad, node_n26_ind_pad(:));
% Restrict the subscript between 2 - mask size + 1
tmp_sub_valid_Q = all( bsxfun(@ge, tmp_sub_pad, [2,2,2]), 2) & ...
    all( bsxfun(@le, tmp_sub_pad, input_graph.num.mask_size_pad - 1), 2);
node_n26_ind = bsxfun(@plus, node_ind', input_graph.num.neighbor_add);
node_n26_link_label = zeros(size(node_n26_ind));
node_n26_link_label(tmp_sub_valid_Q) = full(input_graph.link.map_ind_2_label(node_n26_ind(tmp_sub_valid_Q)));
% Update the link label
node_n26_link_label = input_graph.tmp_link_ind_old_to_new(node_n26_link_label + 1);
if isrow(node_n26_link_label)
    node_n26_link_label = node_n26_link_label';
end
[tmp_neighbor_idx, tmp_voxel_idx, tmp_neighbor_link_label] = find(node_n26_link_label);
tmp_neighbor_ind = zeros(size(tmp_neighbor_idx));
for tmp_idx = 1 : numel(tmp_neighbor_idx)
    tmp_neighbor_ind(tmp_idx) = node_n26_ind(tmp_neighbor_idx(tmp_idx), tmp_voxel_idx(tmp_idx));
end
connected_idx_1 = find(tmp_neighbor_link_label == link_label, 1);
connected_ind_1 = tmp_neighbor_ind(connected_idx_1);
connected_idx_1 = tmp_voxel_idx(connected_idx_1);
% Flip the voxel list, put the voxel that connected to the node to the end.
if link_cc_ind(1) == connected_ind_1
    link_cc_ind = flip(link_cc_ind);
elseif link_cc_ind(end) ~= connected_ind_1
    error('The node is not the endpoint of the link cc.');
end
% Add the node voxel to the end of link cc ind list
node_voxel_in_link = node_ind(connected_idx_1);

new_link_cc = [link_cc_ind; node_voxel_in_link];

% Delete node information
input_graph.node.connected_link_label{node_label} = [];
input_graph.node.cc_ind{node_label} = [];
input_graph.node.num_link(node_label) = 0;

% Update link information
input_graph.link.cc_ind{link_label} = new_link_cc;
link_connected_node = input_graph.link.connected_node_label(link_label, :);
link_connected_node = [link_connected_node(link_connected_node ~= node_label), 0];
input_graph.link.connected_node_label(link_label, :) = link_connected_node;

% Update endpoint information 
input_graph.endpoint.link_label = [input_graph.endpoint.link_label; link_label];
input_graph.endpoint.pos_ind = [input_graph.endpoint.pos_ind; node_voxel_in_link];

new_link_info.ep_ind = node_voxel_in_link;
new_link_info.link_cc_ind = new_link_cc;
new_link_info.length = numel(new_link_info.link_cc_ind);
new_link_info.label = link_label;
end