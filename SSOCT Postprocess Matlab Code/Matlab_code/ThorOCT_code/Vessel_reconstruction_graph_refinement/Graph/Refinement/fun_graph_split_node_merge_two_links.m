function vessel_graph = fun_graph_split_node_merge_two_links(vessel_graph, link_str)
% fun_graph_merge_two_links replace two link with 
% Input: 
%   vessel_graph: structure generated by fun_skeleton_tograph
%   link_str: structure with fields
%       cc_ind: numerical vector, the voxel indices of the new link
%       connected component. 
%       link_pair_label: 1-by-2 numeical vector, the link label of the two
%       links that cc_ind is generated from. 
%       node_label: numerical scalar, node label of the removed node. 
% Output: 
%   vessel_graph: updated structure
% Implemented by Xiang Ji
% Date: 02/17/2019

if ~isfield(vessel_graph, 'tmp_link_ind_old_to_new')
    vessel_graph.tmp_link_ind_old_to_new = 0 : vessel_graph.link.num_cc;
end
%%
if ~isfield(link_str, 'link_pair_label')
    link_pair_label = full(vessel_graph.link.map_ind_2_label(link_str.link_cc_ind));
    link_pair_label = unique(link_pair_label(link_pair_label>0));
    assert(numel(link_pair_label)==2, 'New link connected component contains more than 2 label');
else
    link_pair_label = link_str.link_pair_label;
end
if ~isfield(link_str, 'node_label')
    node_label = unique(full(vessel_graph.node.map_ind_2_label(link_str.node_cc_ind)));
    assert(isscalar(node_label), 'Node voxels are in more than 1 connected components');
else
    node_label = link_str.node_label;
end
link_label_1 = vessel_graph.tmp_link_ind_old_to_new(link_pair_label(1) + 1);
link_label_2 = vessel_graph.tmp_link_ind_old_to_new(link_pair_label(2) + 1);
% Merge the second link to the first link 
connected_node_label_1 = vessel_graph.link.connected_node_label(link_label_1, :);
connected_node_label_2 = vessel_graph.link.connected_node_label(link_label_2, :);
% Merge connected node label
tmp_Q_1 = (connected_node_label_1 ~= node_label);
if nnz(tmp_Q_1) ~= 1
    disp('The other end of the first link to be merged is an endpoint');
end
tmp_Q_2 = (connected_node_label_2 ~= node_label);
if nnz(tmp_Q_2) ~= 1
    disp('The other end of the second link to be merged is an endpoint');
end
new_connected_node_label = [connected_node_label_1(tmp_Q_1), ...
    connected_node_label_2(tmp_Q_2)];
%%
kept_link_label = link_label_1;
rm_link_label = link_label_2;
% Update the kept link information 
vessel_graph.link.cc_ind{kept_link_label} = link_str.link_cc_ind;
vessel_graph.link.connected_node_label(kept_link_label, :) = new_connected_node_label;
% Update the removed link information 
vessel_graph.link.cc_ind{rm_link_label} = [];
vessel_graph.link.connected_node_label(rm_link_label, :) = [0, 0];
vessel_graph.tmp_link_ind_old_to_new(rm_link_label+1) = kept_link_label;
% Update the connected node information 
update_node_label = connected_node_label_2(tmp_Q_2);
if update_node_label
    % Not endpoint
    tmp_link_label_list = vessel_graph.node.connected_link_label{update_node_label};
    tmp_changed_Q = (tmp_link_label_list == rm_link_label);
    assert(nnz(tmp_changed_Q) == 1, 'The merged link is a loop. Please check if the current implementation can handle it correctly.');
    tmp_link_label_list(tmp_changed_Q) = kept_link_label;
    vessel_graph.node.connected_link_label{update_node_label} = tmp_link_label_list;
else
    disp('The merged and removed link has an endpoint');
end

% Endpoint information

% When this function was implemented, the graph relableing function had
% been modified such that only the endpoint voxel indeices are required for
% relabeling. The endpoint link labels were computed using the link voxel
% label map, so here we don't need worry about the whether the deleted lik
% is a endpoint or not, nor do we need to update the endpoint labels.

end