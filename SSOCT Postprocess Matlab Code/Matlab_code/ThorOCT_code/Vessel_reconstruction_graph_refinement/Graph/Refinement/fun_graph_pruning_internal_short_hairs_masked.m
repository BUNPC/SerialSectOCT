function [input_graph, varargout] = fun_graph_pruning_internal_short_hairs_masked(input_graph, th_hair_length, internal_offset, ep_not_to_ind)
% fun_graph_pruning removes all the short links that connected to
% internal endpoints from the graph
% Input: 
%   input_graph: structure, generated by fun_skeleton_to_graph
%   th_hair_length: all the links with free internal points shorter than
%   this threshold are removed
%   internal_offset: if the distance between the endpoint to the boundary
%   is larger than this value, then it is called internal endpoint. 
% Output: 
%   input_graph: graph of the same field as the input
% Note:
% 1. It's true that after removing a link, voxel(s) in the node might be
% removed (or otherwise will become a link with endpoint). But since
% this extra voxel in the node cc does not affect the quantities we
% care about, i.e. connectivity, number of links, link length, this
% algorithm does not remove these voxel from the node, as long as the
% node remian as a node after link removal. 
% 2. For debug, look at debug_graph_pruning_cleanup.m
%
% Written by Xiang Ji, Nov 1, 2018

% Modified by Xiang Ji, Nov 11, 2018
% 1. Convert modules into functions
% 2. Iteratively remove short links

% Modified by Xiang Ji on Dec 6, 2018
% 1. Remove the links in the order of short to long
% 2. Update the link information and check if its current length is longer
% than threshold, skip if yes. 

% Modified by Xiang Ji on Jan 29, 2019
% 1. Convert the nodes of degree 1 to endpoints. 

% Modified by Xiang Ji on Mar 7, 2019
% 1. Do not remove link with 2 endpoints. 

% Note:It's true that after removing a link, voxel(s) in the node might be
% removed (or otherwise will become a link with endpoint). But since this
% extra voxel in the node cc does not affect the quantities we care about,
% i.e. connectivity, number of links, link length, this algorithm does not
% remove these voxel from the node, as long as the node remian as a node
% after link removal.

if nargin < 3
    % Set it to be half of the overlap between neighboring cube
    internal_offset = 16;
end
% Determine the internal endpoints and the link label
block_size = input_graph.num.mask_size;
input_graph.num.neighbor_add = fun_skeleton_neighbor_add_coeff_3D(block_size, 26, true);
internal_bbox = [ones([1,3])*internal_offset, block_size - internal_offset + 1];

endpoint_pos_sub = zeros(input_graph.endpoint.num_voxel, 3);
[endpoint_pos_sub(:,1), endpoint_pos_sub(:,2), ...
    endpoint_pos_sub(:,3)] = ind2sub(input_graph.num.mask_size, input_graph.endpoint.pos_ind);
endpoint_internal_Q = all(bsxfun(@gt, endpoint_pos_sub, ...
    internal_bbox(1:3)),2) & all(bsxfun(@lt, endpoint_pos_sub, ...
    internal_bbox(4:6)),2);
% Length of links of these internal endpoints
endpoint_internal_ind = input_graph.endpoint.pos_ind(endpoint_internal_Q);
ep_link_label = full(input_graph.link.map_ind_2_label(endpoint_internal_ind));
% Do not remove links with two endpoints
node_connected_to = input_graph.link.connected_node_label(ep_link_label, :);
is_link_w_1_ep_Q = any(node_connected_to, 2);
ep_link_label = ep_link_label(is_link_w_1_ep_Q);


link_length = input_graph.link.num_voxel_per_cc(ep_link_label);
link_to_remove_Q = link_length <= th_hair_length;
link_label_to_remove = ep_link_label(link_to_remove_Q);
link_length_to_remove = link_length(link_to_remove_Q);
[~, tmp_ind_sorted] = sort(link_length_to_remove, 'ascend');
link_label_to_remove = link_label_to_remove(tmp_ind_sorted);

% Map the ind to not to remove Q
ind_not_to_remove_Q = sparse(ep_not_to_ind, 1, 1, ...
    input_graph.num.block_voxel, 1);
%% Remove 
num_link_to_remove = numel(link_label_to_remove);
if nargout == 2
    varargout{1} = num_link_to_remove;
end
if num_link_to_remove == 0
%     disp('No link needs to be removed');
    return;
else
%     fprintf('Need to remove %d links\n', num_link_to_remove);
end
input_graph.tmp_link_ind_old_to_new = 0 : input_graph.link.num_cc;
for int_ep_idx = 1 : num_link_to_remove
    link_label = link_label_to_remove(int_ep_idx);  
    % Map the link label to the updated one.
    link_label = input_graph.tmp_link_ind_old_to_new(link_label + 1);
    while ~isempty(link_label) && (link_label ~= 0)
        if input_graph.link.num_voxel_per_cc(link_label) > th_hair_length
%             disp('Link longer than specified length threshold. Do not remove.');
            break;
        end
        tmp_link_ind = input_graph.link.cc_ind{link_label};
        if any(full(ind_not_to_remove_Q(tmp_link_ind)))
            % If any voxels in the link to be deteled contains the voxel
            % that are set to not to delete, then skip this link
%             fprintf('This link contains voxels cannot be deleted.\n');
            break;
        end
        connected_node_label = input_graph.link.connected_node_label(link_label,1);
        % Remove the link:
        [input_graph, updated_node_info] = fun_graph_pruning_remove_single_link(input_graph, link_label);
        if isempty(updated_node_info.label)
%             disp('This link does not connect to any node');
            link_label = [];
            continue;
        end
        if updated_node_info.degree == 2
            [input_graph, new_link_info] = fun_graph_pruning_convert_node_to_link(input_graph, connected_node_label);
            if (new_link_info.num_endpoint == 0) || (new_link_info.length > th_hair_length)
                link_label = [];
            else
                link_label = new_link_info.label;
            end
        elseif updated_node_info.degree == 1
%             fprintf('Node %d in the origninal graph only connects to one link. Convert it to be an endpoint\n', connected_node_label);
            [input_graph, new_link_info] = fun_graph_pruning_convert_node_to_endpoint(input_graph, connected_node_label);
            if new_link_info.length > th_hair_length
                link_label = [];
            else
                link_label = new_link_info.label;
            end
        else
            link_label = [];
        end

    end
end
%% Re-compute the labels
input_graph = fun_graph_relabel(input_graph);
end