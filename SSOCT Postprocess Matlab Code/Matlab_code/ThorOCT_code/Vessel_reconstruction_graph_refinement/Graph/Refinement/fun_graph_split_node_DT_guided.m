function input_graph = fun_graph_split_node_DT_guided(input_graph, vessel_mask_dt, vessel_skl, node_label_list)
% fun_graph_split_node_DT_guided deletes the node of degree 4, pairs the
% remaining 4 and connect pairs by linear regression and shortest path
% searching. 
% Input: 
%   input_graph: structure generated by fun_skeleton_to_graph
%   vessel_mask_dt: 3D numerical array, distance transform of the vessel mask 
%   vessel_skl: 3D logical array, skeleton of the vessel 
%   node_label_list: numerical vector
% Output: 
%   input_graph: updated structure
% Implemented by Xiang Ji, 02/17/2019
%


num_node = numel(node_label_list);
if num_node == 0
    disp('No link needs to be removed');
    return;
else
    fprintf('Need to remove %d links\n', num_node);
end
input_graph.tmp_link_ind_old_to_new = 0 : input_graph.link.num_cc;
image_size = input_graph.num.mask_size;
for iter_node = 1 : num_node
    tmp_node_label = node_label_list(iter_node);
%% For each node
    tmp_node_ind = input_graph.node.cc_ind{tmp_node_label};
    % All the link attached to this node
    tmp_link_label_list = input_graph.node.connected_link_label{tmp_node_label};
    % Update link label 
    tmp_link_label_list = input_graph.tmp_link_ind_old_to_new(tmp_link_label_list + 1);
    
    tmp_link_cc_list = input_graph.link.cc_ind(tmp_link_label_list);
    tmp_num_link = numel(tmp_link_label_list );
    tmp_link_feature = fun_graph_get_link_geometric_features(tmp_link_cc_list, image_size);
    % Find the correspondance between four link segments
    % Determine the endpoints that link to the node
    % 26 neighbor of the node voxel
    tmp_neighbor_ind = unique(fun_skeleton_reconstruction_ind(tmp_node_ind, input_graph.num.mask_size, true([3,3,3])));
    tmp_neighbor_ind_is_linkQ = full(input_graph.link.map_ind_2_label(tmp_neighbor_ind)) > 0;
    tmp_neighbor_link_ind = tmp_neighbor_ind(tmp_neighbor_ind_is_linkQ);
    % Orientation of the links near this ndoe:
    tmp_link_ori = zeros(3, tmp_num_link);
    for iter_link = 1 : tmp_num_link
        tmp_ind = tmp_link_cc_list{iter_link};
        if any(tmp_ind(1) == tmp_neighbor_link_ind)
            tmp_link_ori(:, iter_link) = tmp_link_feature.ep1_direction_vec(iter_link, :)';
        elseif any(tmp_ind(end) == tmp_neighbor_link_ind)
            % Make sure the relevant endpoint is at the begining of the link cc list
            tmp_link_ori(:, iter_link) = tmp_link_feature.ep2_direction_vec(iter_link, :)';
            disp('Flip the cc list');
            tmp_link_cc_list{iter_link} = flip(tmp_ind);
        else
            error('End voxel of the link cc is not in the neighbor of the node');
        end
    end
    % Compute pairwise inner product
    link_ep_cos = zeros(tmp_num_link);
    for iter_1 = 1 : tmp_num_link
        tmp_vec = tmp_link_ori(:, iter_1);
        link_ep_cos(:, iter_1) = tmp_vec' * tmp_link_ori;
        % Zero the diagonal term
        link_ep_cos(iter_1, iter_1) = nan;
    end
%% Pair the links - trust the direction of the vector here
    tmp_min_cos_1 = min(link_ep_cos(:));
    [tmp_idx1, tmp_idx2] = find(link_ep_cos == tmp_min_cos_1, 1);
    % Interpolate the endpoint of the paired link segments
    tmp_pair_idx_1 = [tmp_idx1, tmp_idx2];
    tmp_pair_idx_2 = setdiff(1:tmp_num_link, tmp_pair_idx_1);
    tmp_min_cos_2 = link_ep_cos(tmp_pair_idx_2(1), tmp_pair_idx_2(2));
    if tmp_min_cos_1 > cos(120/180*pi)
        fprintf('Maximum angle between matched link pair is %f degree\n', acos(tmp_min_cos_1)*180/pi);
    end
    if tmp_min_cos_2 > cos(120/180*pi)
        fprintf('Maximum angle between matched link pair is %f degree\n', acos(tmp_min_cos_2)*180/pi);
    end        
%% Get new link
    % Remove the pixels near the node and interpolate the rest of the points to
% get the center voxel position, search the shortest path to connect two
% endpoints and the center point. 
    tmp_pair1_link = fun_graph_split_node_get_new_link(tmp_link_cc_list{tmp_pair_idx_1(1)}, tmp_link_cc_list{tmp_pair_idx_1(2)},...
        tmp_node_ind, vessel_mask_dt, vessel_skl);
    tmp_pair1_link.link_pair_label = tmp_link_label_list(tmp_pair_idx_1);
    tmp_pair1_link.node_label = tmp_node_label;
    
    tmp_pair2_link = fun_graph_split_node_get_new_link(tmp_link_cc_list{tmp_pair_idx_2(1)}, tmp_link_cc_list{tmp_pair_idx_2(2)},...
        tmp_node_ind, vessel_mask_dt, vessel_skl);
    tmp_pair2_link.link_pair_label = tmp_link_label_list(tmp_pair_idx_2);
    tmp_pair2_link.node_label = tmp_node_label;
    
    assert(isempty(intersect(tmp_pair1_link.link_cc_ind, tmp_pair2_link.link_cc_ind)), 'The two new links cross each other');
%% Update graph
    % Merge link pair 1
    input_graph = fun_graph_split_node_merge_two_links(input_graph, tmp_pair1_link);
    % Merge link pair 2
    input_graph = fun_graph_split_node_merge_two_links(input_graph, tmp_pair2_link);
    % Remove node
    input_graph.node.cc_ind{tmp_node_label} = [];
    input_graph.node.connected_link_label{tmp_node_label} = [];
end
%% Re-compute the labels
input_graph = fun_graph_relabel(input_graph);
end