function [linker, paired_ep_ind, found_idx_str] = fun_graph_get_linker_for_int_link(vessel_image, vessel_mask, vessel_skl, int_link)
% fun_graph_get_linker_for_int_link use threshold relaxation to find the
% linkers for internal link with endpoints. 
% Input: 
%   vessel_image: 3D numerical array, image stack
%   vessel_mask: 3D logical array, mask of the vessel 
%   vessel_skl: 3D single array, skeleton of the voxels, whose value is the
%   distance between this point and the boundary
%   int_link: structure generated by fun_graph_get_free_link
% Output: 
%   linker: 1-by-N structure array, with fields defined in
%   fun_graph_get_linker_ep2skl_th_rlx
%   paired_ep_ind: N-by-2 numerical array, indices of paired endpoints
%   whose linkers are found. 
% Note: 
% 1. This function is part of the vessel graph refinenment pipeline. 
%
% Implemented by Xiang Ji on 03/06/2019
%
[paired_ep_ind, found_idx_str] = deal([]);
%% Find linkers for link with 1 endpoints by threshold relaxation 
% clearvars th_rlx_ep1_linker_str

if int_link.ep1.num_cc
    for iter_ep = int_link.ep1.num_cc: -1 : 1
%         if any(iter_ep == [5])
%             disp('Debug');
%         end
        tmp_ep_sub = int_link.ep1.ep_sub(iter_ep, :);
        th_rlx_ep1_linker_str(iter_ep) = fun_graph_get_linker_ep2skl_th_rlx(vessel_image, vessel_mask, ...
            vessel_skl, tmp_ep_sub, int_link.ep_sub);
    end
    found_idx_ep1 = find([th_rlx_ep1_linker_str.foundQ]);
    th_rlx_ep1_linker_str = th_rlx_ep1_linker_str(found_idx_ep1);
    % Find unique linker
    th_rlx_ep1_pair = cat(2, [th_rlx_ep1_linker_str.ep_1_ind]', [th_rlx_ep1_linker_str.ep_2_ind]');
    th_rlx_ep1_pair = sort(th_rlx_ep1_pair, 2, 'ascend');
    [th_rlx_ep1_pair, tmp_unique_idx, ~] = unique(th_rlx_ep1_pair, 'rows', 'stable');
    th_rlx_ep1_linker_str = th_rlx_ep1_linker_str(tmp_unique_idx);
    found_idx_ep1 = found_idx_ep1(tmp_unique_idx);
else
    th_rlx_ep1_linker_str = [];
    th_rlx_ep1_pair = [];
    found_idx_ep1 = [];
end
%% Find linkers for links with 2 endpoints by threshold relaxation
% clearvars th_rlx_ep2_linker_str
% Do not find the linkers for links with two endpoints. 
if int_link.ep2.num_cc && false
    for iter_ep = int_link.ep2.num_cc: -1 : 1
        tmp_ep_sub = int_link.ep2.ep_sub(iter_ep, :);
        th_rlx_ep2_linker_str(iter_ep) = fun_graph_get_linker_ep2skl_th_rlx(vessel_image, vessel_mask, ...
            vessel_skl, tmp_ep_sub, int_link.ep_sub);
    end
    found_idx_ep2 = find([th_rlx_ep2_linker_str.foundQ]);
    th_rlx_ep2_linker_str = th_rlx_ep2_linker_str(found_idx_ep2);
    % Find unique linker
    th_rlx_ep2_pair = cat(2, [th_rlx_ep2_linker_str.ep_1_ind]', [th_rlx_ep2_linker_str.ep_2_ind]');
    th_rlx_ep2_pair = sort(th_rlx_ep2_pair, 2, 'ascend');
    [th_rlx_ep2_pair, tmp_unique_idx, ~]= unique(th_rlx_ep2_pair, 'rows', 'stable');
    th_rlx_ep2_linker_str = th_rlx_ep2_linker_str(tmp_unique_idx);
    found_idx_ep2 = found_idx_ep2(tmp_unique_idx);
else
    th_rlx_ep2_linker_str = [];
    th_rlx_ep2_pair = [];
    found_idx_ep2 = [];
end
if iscolumn(found_idx_ep2)
    found_idx_ep2 = found_idx_ep2.';
end
if iscolumn(found_idx_ep1)
    found_idx_ep1 = found_idx_ep1.';
end
%% Merge two list 
if iscolumn(th_rlx_ep2_linker_str)
    th_rlx_ep2_linker_str = th_rlx_ep2_linker_str';
end
if iscolumn(th_rlx_ep1_linker_str)
    th_rlx_ep1_linker_str = th_rlx_ep1_linker_str';
end
linker = cat(2, th_rlx_ep1_linker_str, th_rlx_ep2_linker_str);
if ~isempty(linker)
    [paired_ep_ind, tmp_unique_idx, ~] = unique(cat(1, th_rlx_ep1_pair, th_rlx_ep2_pair), 'rows', 'stable');
    linker = linker(tmp_unique_idx);
    found_idx_str = struct;
    found_idx_str.ep1 = found_idx_ep1;
    found_idx_str.ep2 = found_idx_ep2;
    found_idx_str.all = cat(2, found_idx_ep1, -found_idx_ep2);
    found_idx_str.all = found_idx_str.all(tmp_unique_idx);
end

end